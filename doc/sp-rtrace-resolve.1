.TH SP-RTRACE-RESOLVE 1 "2010-07-1" "sp-trace-resolve"
.SH NAME
sp-rtrace-resolve - resolve backtrace address function names.
.SH SYNOPSIS
sp-rtrace-resolve \fI<options>\fP
.SH DESCRIPTION
sp-rtrace-resolve is address name resolver. It accepts text data 
generated by post-processor or itself, resolves backtrace
address symbols and generates text format output.
.SS Options:
.TP 
 \fI--help\fP (\fI-h\fP)
Displays help information and exits.
.TP
\fI--output-file\fP=<path> (\fI-o\fP <path)
Specifies the output file for storing resolved trace data. 

By default the data is written to the standard output.
.TP
\fI--input-file\fP=<path> (\fI-i\fP <path>)
Specifies the input file.

By default the data is read from the standard input.
.TP
\fI--mode\fP=<mode> (\fI-m\fP <mode>)
Sets the operation mode where mode can be either multi-pass or
single-cache. By default full cache mode is used where symbols
are cached from all involved libraries. This mode is fastest,
but can result in a heavy memory usage if many debug libraries
are present.

Multi pass mode first splits the input stream into separate
address files for each module, resolves them one by one and 
compiles the resolved output together. This mode uses less memory
and should be used in memory limited environments. However it
uses additional disk space for temporary files and is somewhat 
slower than the full cache mode. Note that the temporary files
are created in the current directory - so if the current directory
is not writable, resolving will fail.

Single cache mode operates similarly the full cache mode. But
instead of caching symbols for each module, only the symbols
of the last loaded module are cached. While this mode should
work always, it's also the slowest (by a lot) mode.
.TP
\fI--method\fP=<method> (\fI-t\fP <method>)
Sets the resolving method which can be either bfd or elf. By
default resolver uses bfd library to extract debug information
if it's present in the default locations. Otherwise it scans
elf symbol table for the target symbol.

With elf method resolver will go straight to the elf symbol
scanning, without attempting to load debug symbols with bfd
library.

With bfd method resolver will not try to scan elf symbol table
if the debug symbols aren't present. Instead it will attempt
to load dynamic symbols with bfd.

Bfd method gives more detailed information though it might be
misleading sometimes when template methods and other inline 
functions are used:
.RS
.IP *
as a general rule one should ignore e.g. Qt (template/inline)
destructors shown for resource _allocation_ paths 
.IP *
gdb can be used to find out the right place in code based on
the address.
.RE
.TP
\fI--full-path\fP (\fI-p\fP)
Keep the path of the function call origin source file. By default
the path is stripped, leaving only file name.
.TP
\fI--keep-resolved\fP (\fI-k\fP)
Keep the resolved address data from the input file. By default
the resolved data from the input file are discared and the
addresses are always resolved again.
.SH EXAMPLES
.TP
sp-rtrace-resolve -i 1235.rtrace.text > 1235.rtrace.resolved
Resolve the trace data from 1235.rtrace.text file and store the
result into 1235.rtrace.resolved file.

.SH SEE ALSO
.IR sp-rtrace (1),
.IR sp-rtrace-postproc (1)
.SH COPYRIGHT
Copyright (C) 2010 Nokia Corporation.
.PP
This is free software. You may redistribute copies of it under the
terms of the GNU General Public License v2 included with the software.
There is NO WARRANTY, to the extent permitted by law.
